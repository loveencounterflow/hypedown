{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/_hypedown-parser-xxx-temp.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n\n'use strict'\n\n\n############################################################################################################\nGUY                       = require 'guy'\n{ alert\n  debug\n  help\n  info\n  plain\n  praise\n  urge\n  warn\n  whisper }               = GUY.trm.get_loggers 'HYPEDOWN-PARSER/XXX-TEMP-HTML'\n#...........................................................................................................\n{ rpr\n  inspect\n  echo\n  log     }               = GUY.trm\n#...........................................................................................................\n{ DATOM }                 = require 'datom'\n#...........................................................................................................\n{ new_datom\n  lets\n  stamp }                = DATOM\n#...........................................................................................................\n{ Pipeline\n  Transformer\n  $\n  transforms }            = require 'moonriver'\n#...........................................................................................................\n{ misfit\n  get_base_types }        = require './types'\nE                         = require './errors'\nH                         = require './helpers'\n{ Hypedown_lexer }        = require './_hypedown-lexer'\n\n\n#===========================================================================================================\nclass @$001_prelude extends Transformer\n\n\n#===========================================================================================================\nclass @$002_tokenize_lines extends Transformer\n\n  #---------------------------------------------------------------------------------------------------------\n  $tokenize_line: ->\n    types = get_base_types()\n    lexer = new Hypedown_lexer()\n    # debug '^3523^', @constructor.name\n    return ( line, send ) ->\n      # debug '^3523^', @constructor.name\n      types.validate.text line\n      send token for token from lexer.walk line\n      return null\n\n#===========================================================================================================\nclass @$010_prepare_paragraphs extends Transformer\n\n  #---------------------------------------------------------------------------------------------------------\n  $consolidate_newlines: ->\n    count       = 0\n    position    = null\n    stop        = Symbol 'stop'\n    template    = { mode: 'plain', tid: 'nls', mk: 'plain:nls', $: 'consolidate_newlines', }\n    #.......................................................................................................\n    flush = ( send ) =>\n      return null if count is 0\n      value         = '\\n'.repeat count\n      position.lnr2 = position.lnr1 + count\n      if count > 1\n        position.lnr2 = position.lnr1 + count - 1\n        position.x2   = 0\n      data          = { count, }\n      nls           = { template..., value, data, position..., }\n      count         = 0\n      position      = null\n      send nls\n    #.......................................................................................................\n    return $ { stop, }, consolidate_newlines = ( d, send ) =>\n      return flush send if d is stop\n      return send d if d.$stamped\n      if d.mk is 'plain:nl'\n        count++\n        throw new Error \"XXX make get_position() static method of Interlex\"\n        position   ?= H.get_position d\n      else\n        flush send\n        send d\n      return null\n\n  #---------------------------------------------------------------------------------------------------------\n  $inject_starter: ->\n    is_first  = true\n    mode      = 'prep'\n    tid       = 'starter'\n    mk        = \"#{mode}:#{tid}\"\n    return ( d, send ) ->\n      return send d unless is_first\n      return send d if /^\\s*$/.test d.value\n      is_first = false\n      send { d..., mode, tid, mk, jump: null, value: '', $: 'inject_starter', }\n      send d\n\n  #---------------------------------------------------------------------------------------------------------\n  $add_parbreak_markers: ->\n    newlines_mk   = 'plain:nls'\n    tid_start     = 'par:start'\n    tid_stop      = 'par:stop'\n    par_start_mk  = 'html:par:start'\n    par_stop_mk   = 'html:par:stop'\n    stop          = Symbol 'stop'\n    has_pars      = false\n    started       = false\n    #.......................................................................................................\n    get_start_token = ( ref ) -> {\n      mode:     'html'\n      tid:      tid_start\n      mk:       par_start_mk\n      value:    ''\n      ( H.get_position ref )...\n      $:        'add_parbreak_markers' }\n    #.......................................................................................................\n    get_stop_token = ( ref ) -> {\n      mode:     'html'\n      tid:      tid_stop\n      mk:       par_stop_mk\n      value:    ''\n      ( H.get_position ref )...\n      $:        'add_parbreak_markers' }\n    #-------------------------------------------------------------------------------------------------------\n    return class add_parbreak_markers extends Transformer\n      $add_stop:              -> $ { stop, }, ( d, send ) -> send d\n      $window:                -> transforms.$window { min: 0, max: +1, empty: null, }\n      $add_parbreak_markers:  -> ( [ d, nxt, ], send ) ->\n        return null if d is stop\n        if d.mk is 'prep:starter'\n          send stamp d\n          started = true\n        return send d unless started\n        if nxt is stop\n          if has_pars\n            send get_stop_token d\n          return send d\n        return send d unless ( d.mk is 'prep:starter' ) or ( H.select_token d, newlines_mk ) and ( d.data.count > 1 )\n        send get_stop_token d if has_pars\n        send d unless d.mk is 'prep:starter'\n        send get_start_token d\n        has_pars = true\n        return null\n\n  # $show_1: -> show_1 = ( d ) -> info d\n\n#===========================================================================================================\nclass @$020_priority_markup extends Transformer\n  ### 'Priority markup': markup that blocks parsing of its contents, like codespans, in which stuff like\n  stars and double stars do not lead to `<em>`, `<strong>` tags ###\n\n  #---------------------------------------------------------------------------------------------------------\n  $parse_md_codespan: ->\n    ### TAINT consider to rewrite using `$window()` transform ###\n    ### TAINT use CFG pattern ###\n    ### TAINT use API for `mode:key` IDs ###\n    enter_mk  = 'cspan:start'\n    text_mk   = 'cspan:text'\n    nl_mk     = 'cspan:nl'\n    escchr_mk = 'cspan:escchr'\n    exit_mk   = 'cspan:stop'\n    collector = []\n    stop      = Symbol 'stop'\n    #.......................................................................................................\n    $flush = ->\n      class Flush extends Transformer\n        $source: -> collector\n        $show_1: -> ( d ) ->\n          urge '^flush.show_1^', collector.length, d\n        $on_stop: -> $ { stop }, ( d ) ->\n          collector.length = 0 if d is stop\n      return Flush.as_pipeline()\n    _flush = $flush()\n    flush = -> yield from _flush.walk_and_stop()\n    # #.......................................................................................................\n    # flush = ->\n    #   last_idx      = collector.length - 1\n    #   first_txt_idx = 1\n    #   last_txt_idx  = last_idx - 1\n    #   lnr1          = ( collector.at  0 ).lnr1\n    #   lnr2          = ( collector.at -1 ).lnr2\n    #   x1            = ( collector.at  0 ).x1\n    #   x2            = ( collector.at -1 ).x2\n    #   texts         = []\n    #   #.....................................................................................................\n    #   for d, idx in collector\n    #     urge '^flush^', d.mk, ( rpr d.value ), ( idx is 0 ), ( idx is last_idx )\n    #     if ( idx is 0 )\n    #       yield stamp d\n    #       yield H.XXX_new_token 'parse_md_codespan', d, 'html', 'tag', 'code', '<code>'\n    #       continue\n    #     #...................................................................................................\n    #     switch d.mk\n    #       when text_mk\n    #         if      idx is first_txt_idx  then  texts.push d.value.trimStart()\n    #         else if idx is last_txt_idx   then  texts.push d.value.trimEnd()\n    #         else                                texts.push d.value\n    #       when escchr_mk\n    #         ### TAINT must properly resolve escaped character ###\n    #         texts.push d.data.chr\n    #       else\n    #         throw new Error \"^^parse_md_codespan@32\", \"internal error: unhandled token #{rpr d}\"\n    #     #...................................................................................................\n    #     if ( idx is last_txt_idx )\n    #       value = texts.join ''\n    #       ### TAINT should not use `html` or must escape first ###\n    #       yield { mode: 'html', tid: 'text', mk: 'html:text', value, lnr1, x1, lnr2, x2, }\n    #   ### TAINT must account for case when parsing ends before closing markup ###\n    #   yield H.XXX_new_token 'parse_md_codespan', d, 'html', 'tag', 'code', '</code>'\n    #   #.....................................................................................................\n    #   collector.length = 0\n    #   return null\n    #.......................................................................................................\n    return parse_md_codespan = $ { stop }, ( d, send ) ->\n      if d is stop\n        send e for e from flush()\n        return null\n      #.....................................................................................................\n      switch d.mk\n        when enter_mk, text_mk, nl_mk, escchr_mk\n          send stamp d\n          collector.push d\n        when exit_mk\n          collector.push d\n          send e for e from flush()\n        else\n          send d\n      #.....................................................................................................\n      return null\n\n\n#===========================================================================================================\nclass @$030_htmlish_tags extends Transformer\n  $: ( require './_hypedown-parser-htmlish' ).Hypedown_parser_htmlish\n\n\n#===========================================================================================================\nclass @$040_stars extends Transformer\n  $: ( require './_hypedown-parser-stars' ).Hypedown_parser_md_stars\n\n\n#===========================================================================================================\nclass @$050_hash_headings extends Transformer\n  $: ->\n    hashes_mk     = \"plain:hashes\"\n    par_start_mk  = 'html:par:start'\n    par_stop_mk   = 'html:par:stop'\n    prv_was_empty = false\n    within_h      = false\n    level         = null\n    position      = null\n    #.......................................................................................................\n    get_start_token = ({ ref, name, level, }) ->\n      return {\n        mode:     'html'\n        tid:      'p:start'\n        mk:       'html:h:start'\n        data:     { name, level, }\n        value:    \"<#{name}>\"\n        ( H.get_position ref )...\n        $:        '050_hash_headings' }\n    #.......................................................................................................\n    get_stop_token = ({ ref, name, level, }) ->\n      position_2    = H.get_position ref\n      position.lnr2 = position_2.lnr2\n      position.x2   = position_2.x2\n      return {\n        mode:     'html'\n        tid:      'p:stop'\n        mk:       'html:h:stop'\n        data:     { name, level, }\n        value:    \"</#{name}>\"\n        position...\n        $:        '050_hash_headings' }\n    #-------------------------------------------------------------------------------------------------------\n    return class add_headings_markup extends Transformer\n      $window:        -> transforms.$window { min: -1, max: +1, empty: null, }\n      $add_headings:  -> ( [ prv, d, nxt, ], send ) ->\n        if ( prv?.mk is par_start_mk ) and ( d.mk is hashes_mk )\n          send stamp d\n          position  = H.get_position d\n          within_h  = true\n          level     = d.data.text.length\n          name      = \"h#{level}\"\n          send get_start_token { ref: d, name, level, }\n        else if within_h and ( nxt?.mk is par_stop_mk )\n          send d\n          name      = \"h#{level}\"\n          send get_stop_token { ref: d, name, level, }\n          level     = null\n          within_h  = false\n          position  = null\n        else\n          send d\n        return null\n\n"
  ]
}