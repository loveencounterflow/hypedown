{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/_hypedown-parser-htmlish.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n\n'use strict'\n\n\n############################################################################################################\nGUY                       = require 'guy'\n{ alert\n  debug\n  help\n  info\n  plain\n  praise\n  urge\n  warn\n  whisper }               = GUY.trm.get_loggers 'HYPEDOWN-PARSER/HTMLISH'\n#...........................................................................................................\n{ rpr\n  inspect\n  echo\n  log     }               = GUY.trm\n#...........................................................................................................\n{ Pipeline\n  transforms  } = require 'moonriver'\nHTMLISH        = ( require 'paragate/lib/htmlish.grammar' ).new_grammar { bare: true, }\nhtmlish_sym     = Symbol 'htmlish'\n#...........................................................................................................\n{ DATOM }                 = require 'datom'\n#...........................................................................................................\n{ new_datom\n  lets\n  stamp }                = DATOM\n\n\n#===========================================================================================================\n#\n#-----------------------------------------------------------------------------------------------------------\n@Hypedown_parser_htmlish = ( clasz = Object ) => class extends clasz\n\n  #---------------------------------------------------------------------------------------------------------\n  $parse_htmlish: ->\n    position  = null\n    collector = null\n    return ( d, send ) ->\n      if d.tid is '$border'\n        if d.x.nxt is 'tag'\n          send d\n          collector = []\n          position  = GUY.props.pick_with_fallback d, null, 'lnr1', 'x1'\n        else if d.x.prv is 'tag'\n          position  = { position..., ( GUY.props.pick_with_fallback d, null, 'lnr2', 'x2' )..., }\n          debug '^345^', position, ( t.value for t in collector ).join '|'\n          ### TAINT use API ###\n          token =\n            mode:       'raw-html'\n            tid:        'tag'\n            mk:         'raw-html:tag'\n            jump:       null\n            value:      ( t.value for t in collector ).join ''\n            # x:          null\n            # $stamped:   null\n            # name:       null\n            lnr1:       position.lnr1\n            x1:         position.x1\n            lnr2:       position.lnr2\n            x2:         position.x2\n            $key:       '^whatever'\n            $:          '^parse_htmlish@1^'\n          #.................................................................................................\n          send ( stamp t ) for t in collector\n          collector = null\n          send token\n          send d\n      else if d.mode is 'tag'\n        collector.push d\n      else\n        send d\n      # urge '^parse_htmlish@1^', d\n    return null\n\n#-----------------------------------------------------------------------------------------------------------\nnew_parser = ( lexer ) ->\n  #.........................................................................................................\n  $tokenize     = ( parser ) ->\n    return tokenize = ( line, send ) ->\n      @types.validate.text line\n      send token for token from parser.lexer.walk line\n      return null\n  #.........................................................................................................\n  $_hd_token_from_paragate_token = ->\n    return _hd_token_from_paragate_token = ( d, send ) ->\n      return send d unless d[htmlish_sym]?\n      first = d.$collector.at  0\n      last  = d.$collector.at -1\n      # delete d.$collector; H.tabulate \"htmlish\", [ d, ]\n      #.....................................................................................................\n      #\n      # * otag      opening tag, `<a>`\n      # * ctag      closing tag, `</a>` or `</>`\n      #\n      # * ntag      opening tag of `<i/italic/`\n      # * nctag     closing slash of `<i/italic/`\n      #\n      # * stag      self-closing tag, `<br/>`\n      #\n      tag_types =\n        otag:       { open: true,  close: false, }\n        ctag:       { open: false, close: true,  }\n        ntag:       { open: true,  close: false, }\n        nctag:      { open: false, close: true,  }\n        stag:       { open: true,  close: true,  }\n      #.....................................................................................................\n      e     =\n        mode:   'tag'\n        tid:    d.type\n        mk:     \"tag:#{d.type}\"\n        jump:   null\n        value:  d.$source\n        ### TAINT must give first_lnr, last_lnr ###\n        lnr:    first.lnr\n        start:  first.start\n        stop:   last.stop\n        x:\n          atrs:   d.atrs\n          id:     d.id\n        source: null\n        $key:   '^tag'\n      send e\n    return null\n  #.........................................................................................................\n  $parse_htmlish_tag  = ->\n    collector   = []\n    within_tag  = false\n    sp          = new Pipeline()\n    sp.push transforms.$window { min: 0, max: +1, empty: null, }\n    sp.push parse_htmlish_tag = ( [ d, nxt, ], send ) ->\n      #.....................................................................................................\n      if within_tag\n        collector.push d\n        # debug '^parse_htmlish_tag@1^', d\n        if d.jump is 'plain' ### TAINT magic number ###\n          within_tag  = false\n          $source     = ( e.value for e from collector ).join ''\n          $collector  = [ collector..., ]\n          send stamp collector.shift() while collector.length > 0\n          htmlish     = HTMLISH.parse $source\n          # H.tabulate '^78^', htmlish\n          # debug '^78^', rpr $source\n          # info '^78^', x for x in htmlish\n          unless htmlish.length is 1\n            ### TAINT use API to create token ###\n            # throw new Error \"^34345^ expected single token, got #{rpr htmlish}\"\n            return send { mode: 'tag', tid: '$error', }\n          [ htmlish ]           = GUY.lft.thaw htmlish\n          htmlish[htmlish_sym]  = true\n          htmlish.$collector    = $collector\n          htmlish.$source       = $source\n          send htmlish\n        return null\n      #.....................................................................................................\n      else\n        return send d unless nxt?.mk.startsWith 'tag:'\n        within_tag = true\n        collector.push d\n      #.....................................................................................................\n      return null\n    sp.push $_hd_token_from_paragate_token()\n    return sp\n  #.........................................................................................................\n  p             = new Pipeline()\n  p.lexer       = lexer\n  p.push $tokenize p\n  p.push $parse_htmlish_tag()\n  # p.push show = ( d ) -> urge '^parser@1^', d\n  # debug '^43^', p\n  return p\n"
  ]
}