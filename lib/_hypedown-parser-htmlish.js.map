{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/_hypedown-parser-htmlish.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n\n'use strict'\n\n\n############################################################################################################\nGUY                       = require 'guy'\n{ alert\n  debug\n  help\n  info\n  plain\n  praise\n  urge\n  warn\n  whisper }               = GUY.trm.get_loggers 'HYPEDOWN-PARSER/HTMLISH'\n#...........................................................................................................\n{ rpr\n  inspect\n  echo\n  log     }               = GUY.trm\n#...........................................................................................................\n{ Pipeline\n  transforms  } = require 'moonriver'\nHTMLISH         = ( require 'paragate/lib/htmlish.grammar' ).new_grammar { bare: true, }\n#...........................................................................................................\n{ DATOM }                 = require 'datom'\n#...........................................................................................................\n{ new_datom\n  lets\n  stamp }                 = DATOM\nTR                        = require './tag-registry'\n\n\n#===========================================================================================================\n#\n#-----------------------------------------------------------------------------------------------------------\n@Hypedown_parser_htmlish = ( clasz = Object ) => class extends clasz\n\n\n  #---------------------------------------------------------------------------------------------------------\n  _hd_token_from_paragate_token: ( hd_token, pg_token ) ->\n    #.......................................................................................................\n    tid = if pg_token.$key is '^error' then '$error' else TR.pg_and_hd_tags[ pg_token.type ]?.type ? '???'\n    R =\n      mode:   'tag'\n      tid:    tid\n      jump:   null\n      value:  hd_token.value\n      ### TAINT must give first_lnr, last_lnr ###\n      data:   { TR.pg_and_hd_tags[ pg_token.type ]..., }\n      lnr1:   hd_token.lnr1\n      x1:     hd_token.x1\n      lnr2:   hd_token.lnr2\n      x2:     hd_token.x2\n    R.mk        = \"#{R.mode}:#{R.tid}\"\n    R.data.atrs = pg_token.atrs if pg_token.atrs?\n    R.data.id   = pg_token.id   if pg_token.id?\n    if pg_token.$key is '^error'\n      R.data.code     = pg_token.code\n      R.data.message  = pg_token.message\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  $parse_htmlish: ->\n    p = new Pipeline()\n    p.push @$_normalize_tag_tokens()\n    p.push @$_collect_tag_tokens()\n    p.push @$_parse_tag_source()\n    p.push @$_parse_sole_slash()\n    return p\n\n  #---------------------------------------------------------------------------------------------------------\n  $_normalize_tag_tokens: =>\n    return _normalize_tag_tokens = ( d, send ) =>\n      return send d unless d.mode is 'tag'\n      return send d unless ( data = TR.pg_and_hd_tags[ d.tid ] )?\n      debug '^_normalize_tag_tokens@1^', d.mk, ( rpr d.value ), data\n      send GUY.lft.lets d, ( d ) -> d.data = { d.data..., data..., }\n\n  #---------------------------------------------------------------------------------------------------------\n  $_collect_tag_tokens: =>\n    position  = null\n    collector = null\n    return _collect_tag_tokens = ( d, send ) =>\n      if d.tid is '$border'\n        #...................................................................................................\n        if d.data.nxt is 'tag'\n          send d\n          collector = []\n          position  = GUY.props.pick_with_fallback d, null, 'lnr1', 'x1'\n        #...................................................................................................\n        else if d.data.prv is 'tag'\n          if ( first_token = collector[ 0 ] )?.mk is 'tag:c_lsr'\n            collector = null\n            return send first_token\n          #.................................................................................................\n          position  = { position..., ( GUY.props.pick_with_fallback d, null, 'lnr2', 'x2' )..., }\n          # debug '^345^', position, ( t.value for t in collector ).join '|'\n          ### TAINT use API ###\n          token =\n            mode:       'raw-html'\n            tid:        'tag'\n            mk:         'raw-html:tag'\n            jump:       null\n            value:      ( t.value for t in collector ).join ''\n            # x:          null\n            # $stamped:   null\n            # name:       null\n            lnr1:       position.lnr1\n            x1:         position.x1\n            lnr2:       position.lnr2\n            x2:         position.x2\n            $key:       '^whatever'\n            $:          '^parse_htmlish@1^'\n          #.................................................................................................\n          send ( stamp t ) for t in collector\n          collector = null\n          send token\n          send d\n      else if d.mode is 'tag'\n        collector.push d\n      else\n        send d\n      # urge '^parse_htmlish@1^', d\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  $_parse_tag_source: =>\n    return _parse_tag_source = ( d, send ) =>\n      return send d unless d.mk is 'raw-html:tag'\n      # send stamp d ### NOTE intentionally hiding `raw-html` token as it is condiered an implementation detail ###\n      pg_tokens = HTMLISH.parse d.value\n      # unless pg_tokens.length is 1\n      #   ### TAINT use API to create token ###\n      #   return send { mode: 'tag', tid: '$error', \\\n      #     data: { message: \"expected single token, got #{rpr pg_tokens}\", }, $: '^_parse_tag_source@1^', }\n      # [ pg_token ]           = GUY.lft.thaw pg_tokens\n      send @_hd_token_from_paragate_token d, pg_token for pg_token in pg_tokens\n      return null\n\n  #---------------------------------------------------------------------------------------------------------\n  $_parse_sole_slash: =>\n    tag_type_stack = []\n    return _parse_sole_slash = ( d, send ) =>\n      switch d.mk\n        when 'tag:otag', 'tag:ctag', 'tag:ntag', 'tag:nctag', 'tag:stag'\n          tag_type_stack.push d.type\n          send d\n        when 'plain:slash'\n          # debug '^_parse_sole_slash@1^', tag_type_stack\n          send stamp d\n          null\n        else\n          send d\n      return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# new_parser = ( lexer ) ->\n\n#   #.........................................................................................................\n#   $_hd_token_from_paragate_token = ->\n#   #.........................................................................................................\n#   $parse_htmlish_tag  = ->\n#     collector   = []\n#     within_tag  = false\n#     sp          = new Pipeline()\n#     sp.push transforms.$window { min: 0, max: +1, empty: null, }\n#     sp.push parse_htmlish_tag = ( [ d, nxt, ], send ) ->\n#       #.....................................................................................................\n#       if within_tag\n#         collector.push d\n#         # debug '^parse_htmlish_tag@1^', d\n#         if d.jump is 'plain' ### TAINT magic number ###\n#           within_tag  = false\n#           $source     = ( e.value for e from collector ).join ''\n#           $collector  = [ collector..., ]\n#           send stamp collector.shift() while collector.length > 0\n#           htmlish     = HTMLISH.parse $source\n#           # H.tabulate '^78^', htmlish\n#           # debug '^78^', rpr $source\n#           # info '^78^', x for x in htmlish\n#           unless htmlish.length is 1\n#             ### TAINT use API to create token ###\n#             # throw new Error \"^34345^ expected single token, got #{rpr htmlish}\"\n#             return send { mode: 'tag', tid: '$error', }\n#           [ htmlish ]           = GUY.lft.thaw htmlish\n#           htmlish[htmlish_sym]  = true\n#           htmlish.$collector    = $collector\n#           htmlish.$source       = $source\n#           send htmlish\n#         return null\n#       #.....................................................................................................\n#       else\n#         return send d unless nxt?.mk.startsWith 'tag:'\n#         within_tag = true\n#         collector.push d\n#       #.....................................................................................................\n#       return null\n#     sp.push $_hd_token_from_paragate_token()\n#     return sp\n#   #.........................................................................................................\n#   p             = new Pipeline()\n#   p.lexer       = lexer\n#   p.push $tokenize p\n#   p.push $parse_htmlish_tag()\n#   # p.push show = ( d ) -> urge '^parser@1^', d\n#   # debug '^43^', p\n#   return p\n"
  ]
}